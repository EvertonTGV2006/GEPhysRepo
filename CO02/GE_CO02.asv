%CO02 Gareth Everton

%Ex1: Non linear Equation solver: Lines 3 - 59
%Ex2: Numerical Integration: Lines 60 - 

%Mathematical Functions: 
function y = fx(x) %f(x) in Ex1
    y = 3 * exp(-x) -x + 3; % evaluates the function f(x) = 3e^-x - x +3
end

function y = dfx(x) %f'(x) in Ex1
    y = -3 * exp(-x) -1; % evaluates the function f'(x) = df/dx = -3e^-x -1
end

function y = gx(x) % erf(x) for Ex2
y = exp(-(x.^2)) * 2 * pi.^-0.5;
end

function y = hx(x) % 2nd func for Ex2
y = (sin(100 * pi * x)).^2 * exp(-(x.^2));
y = y * 2 * pi.^-0.5;
end



function [xRoot, i] = bisectionRoots(x1, x2, acc) %x1, x2 are inputs of opposite sign, acc is number of dp of accuracy
y1 = fx(x1);
y2 = fx(x2);
i = 0;

accCheck = false;
while accCheck ==false
  
    x3 = (x1 + x2) / 2; %evaluate midpoint

    y3 = fx(x3); % evaluate new value of f
    if ((y1 > 0 && y3 > 0) || (y1 <0 && y3 <0))
        y1 = y3; % if y1 & y3 are of the same sign, assign y3,x3 to y1,x1
        x1 = x3; % could only reassign x, but copying y eliminates an additional call to f(x) each iteration and is more performant
    else
        y2 = y3; %if not then must be of same sign as y2 & x2, so assign to those instead
        x2 = x3;
    end
    if round(x1, acc) == round(x2, acc)% now carry out accuracy checks, if the rounded versions match we have converged on a root to acc many d.p. so we can break out of the loop
        accCheck = true;
    end
    i = i+1;
end
xRoot = round(x1, acc); % set return value
end

function [xRoot, i] = newtRaph(x1, acc) %similar to before, but 1 less input

i = 0;
accCheck = false;
while accCheck == false
    y1 = fx(x1); % calculate values
    dy1 = dfx(x1);
    x2 = x1 - (y1 / dy1); % apply newtRaphs method
    i = i+1; %increment iteration counter
    if round(x1, acc) == round(x2, acc)% same acc check as before
        accCheck = true;
    end
    x1 = x2;
end
xRoot = round(x1, acc); % set return value
end



%Ex2: Simpsons Rule

function area = simpsonsRule(fx, x1, x2, n)
h = (x2 - x1) / n;
y1 = fx(x1); %evaluate first and last values
y2 = fx(x2);
workingSum = y1 + y2; %start working sums %"ends x 1"
for i = 1:(n-1)
    if mod(i, 2) == 0 
        workingSum = workingSum + 2 * fx(x1 + i * h); %"evens" * 2
    end
    if mod(i,2) == 1
        workingSum = workingSum + 4 * fx(x1 + i * h); %"odds"  * 4
    end
end
area = workingSum * h / 3;
end





















fileID = fopen('GE_CO02_Output.csv', 'w'); %open File for data output
ex = 1; %set exercies number
%Main code
switch ex
    case 1
        % Find root about x = 3; so take x1 = 2  and x2 = 4, let acc = 3d.p
        acc = 10;
        [bisRoot, bisIterations] = bisectionRoots(2, 4, acc);
        % now take x1 = 3 for newtRaph , acc still = 3;
        [newRoot, newIterations] = newtRaph(3, acc);
        matRoot = fzero(@fx, 3);
    
        %now write output to file
        fprintf(fileID, '%s', ["Bisection Method:, ", num2str(bisRoot, 10), ', ', num2str(bisIterations), newline]);
        fprintf(fileID, '%s', ["Newton-Raphson Method:, ", num2str(newRoot, 10), ', ', num2str(newIterations), newline]);
        fprintf(fileID, '%s', ["MATLAB fzero() Method:, ", num2str(matRoot, 10), newline]);


    case 2     %Ex 2, simpsons rule

    %Initialse all the variables
    X_Values = transpose([0.2, 0.4, 0.6, 0.8, 1.0]);
    N_1_Values = zeros(length(X_Values),1);
    N_10_Values = zeros(length(X_Values),1);
    N_100_Values = zeros(length(X_Values),1);
    ERF_Values = zeros(length(X_Values),1);

    for iX = 1:length(X_Values) %Calculate area for each x input using simpsons rule and store it in an array
        N_1_Values(iX,1) = simpsonsRule(@gx, 0, X_Values(iX), 1);
        N_10_Values(iX,1) = simpsonsRule(@gx, 0, X_Values(iX), 10);
        N_100_Values(iX,1) = simpsonsRule(@gx, 0, X_Values(iX), 100);
        ERF_Values(iX,1) = erf(X_Values(iX));
    end
    fprint(fileID, '%s',["Integral of Error Function (Part A) using Simpson's Rule: X N = 1, N = 10, N = 100, MATLAB erf(x)", newline]);
    for iX = 1:length(X_Values)
        fprintf(fileID, '%s', [num2str(X_Values(iX), 2), ', ', num2str(N_1_Values(iX), 10), ', ', num2str(N_10_Values(iX), 10), ', ', num2str(N_100_Values(iX), 10), ', ', num2str(ERF_Values(iX), 10), newline]);
    end
    fprintf(fileID, '%s', newline);

    % now calculate for oscillatory function
    for iX = 1:length(xValues)
        N_1_Values(iX,1) = simpsonsRule(@hx, 0, X_Values(iX), 1);
        N_10_Values(iX,1) = simpsonsRule(@hx, 0, X_Values(iX), 10);
        N_100_Values(iX,1) = simpsonsRule(@hx, 0, X_Values(iX), 100);
    end
    fprintf(fileID, '%s', ["Integral of Oscillatory Function (Part B) using Simpon's rule: X, N = 1, N = 10, N = 100", newline])

end
fclose(fileID);



